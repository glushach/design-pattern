/* Флайвэй (Легковес, Приспособленец, Кещ) -
  Легковес патерн, который позволяет вместить больше количество определенных
  объектов в выделеную оперативную память. Другими словами он позволяет экономить
  ресурсы рзделяя общее состояние объектов между собой. Вместо хранения одинаковых
  данных в каждом объекте, что в своем роде похоже не кеширование данных.

  Допустим, что есть 100 объектов из разной структурой, но так получилось, что в каждом
  из объектов есть общее свойство. Это позволяет создать нам 1 класс, где собрать все
  повторяющиеся свойства, после чего установить связь между этим классом и остальными классами
  где эти свойства используються. Таким образом мы съекономим память, которая потребуеться
  для хранения этих свойств.
  Также в него есть несколько особенностей:
  1. Неизменяемость, так как одни и те же данные вы передаете во множество объектов,
  вы должны точно убедиться, что свойства легковеса невозможно изменить после создания,
  то есть все свое внутренее состояние он должен получить через параметры конструктора
  и у него не должно быть никаких публичных полей из сетеров.
  2. Создавать легковесы и работать с ними намного удобнее с помощью фабрик. В этом
  случае мы можем создать фабрику, которая принимает в параметрах все внутренее состояние
  легковеса. Главная польза состоит в том, что польза состоит в том, что с помощью
  такой реализации можно искать уже созданные легковесы с таким же внутренним состоянием
  и если подобный легковес уже существует, то спокойно можно использовать его.
  Если же нет, то создать новый.
*/

// Создадим класс легковека. Это кк раз то, что будет кешироваться
class Auto {
  constructor(model) {
    this.model = model;
  }
}

// Вся суть реализации заключаеться в этой фабрике
class AutoFactory {
  constructor(name) { // name модкль авто
    this.models = {}
  }

  create(name) { // фабричный метод
    let model = this.models[name]; // создаеться поле name
    if (model) return model; // проверка существует ли модель
    console.count('model')
    this.models[name] = new Auto(name);
    return this.models[name];
  }

  getModels() {
    console.log(this.models)
  }
}
/* create принимакт model, после чего идет в объект models и присваивает
  определенную модель, после его идет проверка, а есть ли вообще данная
  модель. Конечно на начальных этапах, когда легковес пустой, то никаких модлей
  в нем нету. Но постепенно он начинает наполняться этими свойствами и тем не мение
  мы проверяем существует ли объект. И если он есть, то мы его возвращаем, если нету,
  то в свойство model мы записываем этот объект и соответсвенно возращаем ссылку на
  него.

  ИТОГ: Легковес предназначаеться для экономии памяти занимаемыми объектами.
  Если объект не еще создан, он создает его и помещает его в свой внутренный пул.
  Если объект уже создан, то он содержиться в пуле, то просто возвращаеться ссылка
  на него.
*/

const factory = new AutoFactory();

const bmw = factory.create('BMW');
const audi = factory.create('Audi');
const tesla = factory.create('Tesla');
const blackTesla = factory.create('Tesla')

console.log(factory.getModels())

/*
  model: 1
  model: 2
  model: 3
  {
    BMW: Auto { model: 'BMW' },
    Audi: Auto { model: 'Audi' },
    Tesla: Auto { model: 'Tesla' }
  }

  ┌─────────┬─────────┐
  │ (index) │  model  │
  ├─────────┼─────────┤
  │   BMW   │  'BMW'  │
  │  Audi   │ 'Audi'  │
  │  Tesla  │ 'Tesla' │
  └─────────┴─────────┘
*/

/* Создаеться экземпляр фабрики. Затем через метод create
  запролняем ее различными моделями. Причем Tesla идет 2 раза.
  По консоли видно, что все обрабатываеться правильно. Моделей создалось
  3 и столько же раз инициализировали обращение к лекговесу Auto
  В 4 раз при повторном создании Tesla мы получили ссылку на существующий
  модель. В последующем мы можем расширить созданный объект под наши нужды
*/

// node flyweight