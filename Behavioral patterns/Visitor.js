/* Посетитель - патерин, суть которого заключаеться в том, что он добавляет
 новую функциональность к уже существующим классам. Причем делает он это не
 изменяя исходный код классов. Другими словами он разширяет функциональность
 класса не изменяя его первоначальную реализацию

 В каких сутуациях он нужен? В действительности спектр его применения довольно большой,
 так как разширение программы идет постоянно. Но представим такую ситуацию:
 Мы разрабатываем приложение для авто и каждое авто это отдельный класс. Внутри данных
 классов определены свойства, которые задают технические характеристики авто, определены
 необходымые методы, которые помогают взаимодействовать с классом и производить нужные
 операции. Поскольку вся эта структура разрабатывалась давно, то она довольно стабильно
 работает и покрыта тестами. Но приходит требование клиента о том, что ему нужно
 экспортировать данные из этих классов. Казалось бы, что решение довольно простое.
 Это добавить метод экспорта в каждый класс и таким образом добавить возможность
 экспортирования данных из класса. Но беда в том, что все текущие классы работают
 довольно стабильно и плюс ко всему "на носу" может быть релиз. И обновлять каждый
 класс, добавляя в него дополнительную логику - это довольно рискованное мериприятие,
 так как все эти изменения нужно протестировать, после чего переписать уже существующие
 тесты. Поетому подход с изменениями исходных классов отмепняеться. Вот в таких сутуациях
 приходит на помощь патерн посетитель. Он добавить нужную вам функциональность не
 изменяя классы.

Для начала определим уже существующие классы с устоявшейся и проверенной структурой.
Как видно, что есть 3 однотипных класса. Каждый из классов содержит метод info, который
возвращает какую-то информацию об авто и метод accept, который осуществляет связь класса
с нешним миром. Данный метод может брать посетителя и передавать этому посетителю контекст
вызова класса.
 */
class Auto {
  accept(visitor) {
    visitor(this);
  }
}


class Tesla extends Auto {
  info() {
    return 'It is a Tesla car!';
  }
}

class Bmw extends Auto {
  info() {
    return 'It is a BMW car!';
  }
}

class Audi extends Auto {
  info() {
    return 'It is a Audi car!';
  }
}

/* Описываем посетителя. Как вы вилите - это просто функция, которая на основании контекста
  определяя его с помощью instanceof, задает в объекте метод export, в котором и описанная
  имплементация экспортирования данных.
*/
function exportVisitor(auto) {
  if (auto instanceof Tesla) {
    auto.export = console.log(`Exported data: ${auto.info()}`);
  }
  if (auto instanceof Bmw) {
    auto.export = console.log(`Exported data: ${auto.info()}`);
  }
  if (auto instanceof Audi) {
    auto.export = console.log(`Exported data: ${auto.info()}`);
  }
}

/* Провераяем реализованную функциональность. Создаються 2 метода авто, после чего с
 помощью патерна просетителя добавили добавили в каждый из объектов метод экспорт и
 вызвали его, получив соответсвующий результат в консоль.

 Одиин момент, который не нравится, то что каждый класс сожержит один и тот меж метод
 accept. И чтобы не повторяться, мы можем вынести этот метод в отдельный класс Auto
 и через extends отнаследовать наши классы от него. Основная имплементация от этого не
 измениться, просто мы избавимся от повторяющихся кусков кода.

 */
const tesla = new Tesla();
const bmw = new Bmw();

console.log(tesla.accept(exportVisitor)); // Exported data: It is a Tesla car!
console.log(bmw.accept(exportVisitor));   // Exported data: It is a BMW car!

/* ИТОГ: Патерн посетитель помгает расширить возможности сущесмтвующих классов
   не изменяя их исходный код и имплементацию.
*/
// node Visitor