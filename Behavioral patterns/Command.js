/* Команда - это патерн, который помогает инкапсулировать некоторые действия и
 необходимые для них данные м таким образом позволяет отделить клиента от получателя.
 Можно также сказать, что он превращает запросы в объекты. Что позволяет передавать их
 как аргументы в методы.

 Теория. Что-то подобное рассматривалось в патерне снимок. Представтье, что вы разарабатываете
 редактор и как вы понимаете у него есть куча кнопок. Как снопки редактирования текста
 и общей стилистики, так и копоки печати, сохранения, востановления и тд. Как реализовать
 данную логику. Ну логичнее всего - это создать базовый класс кнопки. Дальше по нажатию на
 кнопку должно что-то происходить. Если простыми словами, должен срабатывать какой-то ивент
 хендлер, но класс для кнопок у нас всего один, а действия разные.
 Тут можно заимплементировать вариант создания различных подклассов со своим хендлером внутри,
 после чего после наследования добавлять необходимые алгоритмы каждой из кнопок. Но в этой
 реализации есть поблема. С ростом приложения этих подклассов будет становиться все больше и
 больше. И мало того, вас механизм взаимодейсствия будет прямым, то есть пользователь кликнул на кпопку
 и этот кли к напрямую вызвал какое-то событие внутри программы. И это не всегда правильно.
 Именно поетому была введена слоенная структура приложения. Если говорить проще, то появилась
 дополнительная простойка из бизнес логики.

 То есть у нас появляеться то, что рисует интерфейс и то, что производит какие-то действия.
 Табим образом объект интерфейсам вызывает метод из объекта бизнес логики, передавая в него
 какие-то данные. И вот тут выходит на сцену патерин команда, который предпологает не
 отправлять такие вызовы напрямую, а каждый из этих вызовов оборачивать свой класс, и только
 внутри этого класс осуществлять вызов. То есть - это своеобразный патерн посредник.
 Из всего этого подводя итог, можно сказать следующие. Что между интерфейсом и бизнс логикой
 появляеться прослойка из патерна команда, в котором инкапсулирована логика уникального
 запроса. Условно говоря, в том же тестовом редакторе мы можем создать кнопку сохранить
 и добавить эту кнопку в разные места плюс добавить сочетане клавиш Ctrl + S. Но каждая из
 этих кнопок и клавишная команда будуть дергать одно события - сохранить. Логика этого события
 будет в команде, но исполнение этого запроса будет в бизнес-логике. И в сою очередь
 бизнес-логика не будет содержать это уникальное событие.

 Чтобы было проще разобраться в дополнительном слое в виде патерна, размотрим как обычно это
 на примере авто.
*/

/* Для начала создадим класс Driver. Как вы можете выдеть, внутри данного класса мы
  определяем команду. В нашем случае это будуть команды старта двигателя и его остановки.
  Также в этом классе будет метод execute, где непосредственно осуществляеться вызов этой
  команды. Driver выступает в роли кнопки, или элемента интерфейса.
*/

class Driver {
  constructor(command) {
    this.command = command;
  }

  execute() {
    this.command.execute();
  }
}

/* Определение класса дигателя. Внутри этого класса у нас определено состояние
 двигателя. То есть включен включен он или выключен. По умолчанию двигатель у нас
 конечно же выключен. Плюс дополнительно в класе определено два метода - on и off,
 которые либо этот двигатель заводять либо останавлювают. И в этом случае двигатель
 выступает как прослойка бизнес-логики, то есть итоговое звено, или результат
 выполнения какой-то команды. Сразу обратите внимание, между водителем и запуском
 двигателя нет прямого взаимодействия. Даже в реальной жизни водителю нет необходимости
 залазить под капот и запускать двигатель вручную. Дляы этого у кодителя есть ключ
 зажигания. Тем самым, водитель вставляя ключ зажигания, запускает двигатель.
 Этот самый ключ есть шаблон команды

*/
class Engine {
  constructor() {
    this.state = false;
  }

  on() {
    this.state = true;
  }

  off() {
    this.state = false;
  }
}

/* Шаблон команды. Методом execute дергаеться тот или иной метод внутри класса
  двигателся. Именно инкапсулированными командами OnStartCommand и onSwitchOffCommand.
  Заппускаеться и останавливаеться двигатель. Именно в этом патерне происходит вызов.
  Он не делегируеться в класс Engine, а исполняеться внутри шаблона команды.
  Таким образом, у нас есть конечный пользователь, который знает о командах, есть команды,
  которые знают о бизнес логике и есть бизнес логика, которая в зависимости от команды
  испольняет тот или иной кусок. Последнее. что у нас осталось - это проверить
  имплементацию
*/
class OnStartCommand {
  constructor(engine) {
    this.engine = engine;
  }

  execute() {
    this.engine.on();
  }
}

class onSwitchOffCommand {
  constructor(engine) {
    this.engine = engine;
  }

  execute() {
    this.engine.off();
  }
}

/* Проверка имплементации. Как выдите мы создали инстанс двигателя и убедились,
  что он вывключен. Далее мы создали экземпляр специфической команды, которая запускает
  двигатель и передали ей этот самый двигатель, чтобы она знала, что запускать.
  После чего мы создали пользователя илии водителя и передали ему команду запуска
  двигателя. То есть вручили ключ от зажигания и все благополучно завелось.
 */
const engine = new Engine();

console.log(engine); // Engine { state: false }

const onStartCommand = new OnStartCommand(engine);
const driver = new Driver(onStartCommand);
driver.execute();

console.log(engine) // Engine { state: true }

// node Command