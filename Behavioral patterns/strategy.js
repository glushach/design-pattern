/* Стратегия - патерин, который определяет схожие алгоритмы и помещвет их в
    каждый отдельный класс, после чего между этими алгоритмами можно автоматически
    переключаться входе выполнения программы.

    Когда и зачем может понадобиться?? В основном при расширении приложения, чтобы не
    превратить код в не читаемое или трудно поддерживаемое полотно.
    Вот представтье такой кейс. Вы разработали приложение, которое следит за километражом
    вашего авто и советует в зависимости от пробега проверить или заменить ту или иную
    деталь. И разработали вы это приложение только для одной марки авто. Предтвим, что все
    получилось и приложение выстрелило и вас попросили разработать аналогичный
    функционал еще для одной или двух марок. В целом большинстве своем все операции и их
    последовательности выполнения могут совпадать. Но из-за особенности каждой марки авто
    везьде есть свои ньюансы. В результате чего при разарботке могут затрагиваться одни и те
    же классы, либо они могуть постоянно исменяться либо раширяться. И это создает
    определенные трудности. Тем более если разработка ведеться паралельно несколькими
    командами. Патерин стратегия позволяют избежать таких узких мест в инплементации
    Он выделяет семейства схожих алгоритмов и момещает их в отдельный класс.
    Фактически эти классы и называються стратегиями. Нюанс, что все стратегии
    должны иметь одинаковый интерфейс взаимодействия. После чего у нас есть один глобальный или
    корневой класс, который в зависимости от той или иной ситуации делегирует выполнение
    алгоритмов на ту или инную стратгию, причем происходит это в полне динамически во время
    выполнеия программы. Сам же объект в свою очередь называеться контекстом, так как просто
    носит ссылку на нужную стртегию.

    Реализовать стратегию можно с помощью функции первого класса, ну или если говорить обычными
    словами, то с помощью простых функций.
    */

/* Обычные функции вместо стрелочных используються, потому что они всплывают и могут
    быть вызваны на более высоких уровнях, до есть до своего определения. В текущейц реализации
    можно использовать и стреочные, потому что мы сначала определяем функции, а потом контекст.
    Этот вариант используеться, чтобы показать, что при ООП вполне допустимо использовать и
    обычные функции.

    Есть 3 однотипные функции, которые на вход принимают стоимость авто и в зависимости от той
    или инной стратегии делают скидку. Условно говоря, когда вы покупаете авто у диллера,
    чтобы стимурировать вышу заинтересованность, вам могут выдать карту клиента, со скидкой
    на покупку следующего авто. Причем, купив несколько авто, размер скидки может увеличиваться.

*/
function baseStrategy(amount) {
  return amount;
}

function premiumStrategy(amount) {
  return amount * 0.85;
}

function platinumStrategy(amount) {
  return amount * 0.65;
}

/* Создаем класс контекст AutoCart. Но вход он принимает размер скидки discount. В нашем
 случае данный класс будет принимать ту или инную стратегию, после чего в зависимости от
 выбранной стратегии у нас будет расчитываться итоговая сумма. Здесь тоже все элементарно.

 Создаем различные типы клиентов, чтобы посмотреть, как стратегия работает. За базовую
 стомость возьмем 50000
 */
class AutoCart {
  constructor(discount) {
    this.discount = discount;
    this.amount = 0;
  }

  checkout() {
    return this.discount(this.amount);
  }

  setAmount(amount) {
    this.amount = amount;
  }
}

const baseCustomer = new AutoCart(baseStrategy);
const premiumCustomer = new AutoCart(premiumStrategy);
const platinumCustomer = new AutoCart(platinumStrategy);

baseCustomer.setAmount(50000);
console.log(baseCustomer.checkout());      // 50000

premiumCustomer.setAmount(50000);
console.log(premiumCustomer.checkout());   // 42500

platinumCustomer.setAmount(50000);
console.log(platinumCustomer.checkout())   // 32500

/* Мы взяли за базу 50000, просмотрели как расчитываеться скидка выходя из
 выбранной стратегии. Создали 3 типа разных клиентов с разными картами.
 Каждой карте прикреплена своя стратегия. Далее базовая сумма 50000. Она
 передаеться в аргумент метода setAmount, после чего мы проверяем итоговый счет
 которому применяеться та или инная скидка.

 ИТОГ: Стратегия - патерин, который объединяет сложные алгоритмы в классы, а
 затем в зависимости от условия, динамически дергает тот или инной класс,
 тем саммы динамически заменяя их друг другом в процесе выполнения программы.
 */

// node strategy