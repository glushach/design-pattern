/* Патерин наблонный метод - определяет базовые шаги исполнения алгоритма и
 выполнение каждого из этих шагов делигирует на соответсвующие методы или
 подклассы. Если привести пример из реальной жизни, то мы можем представить сборочный цех
 любого авто. В большинстве своем операции сборки а=выполняються по определенным шагам.
 Изначально есть пустой кузов. Потом туда помещветься двигатель, ходовая, электроника,
 комплектующие. Так происходит практически при сборке каждого авто. Это и есть шаблоны
 механизма сборки или юазовый скелет выполнения алгоритмов. А вот то, что в одно авто
 устанавливаеться бензиновый двигатель, а в другой электродвигатель, или то что в одном
 использвуються запчасти одной марки и устанавливаються они в определенной последовательности
 а другом и запчасти и их марка и порядок установки полностью другие - это и есть подклассы
 со своей специализированной логикой имплементации. Однако все эти операции или алгоритмы
 определены внутри шаблонного класса и вызываеться в определенном порядке.

 Созадем корневой (базовый) класс Builder, в котором определен порядок выполнения операций
 В нем есть шаблонный метод build. Внутри мы определили порядок вызова всех стандартных
 операций по сборке авто.
 */
class Builder {
  build() {
    this.addEngine();
    this.installChassis();
    this.addElectronic();
    this.collectAccessories();
  }
}

/* Поскольку есть несколько автомобилей различных  марок мы определяем классы этых
 авто и в каждый класс помещвем соответсвующие методы. Ну и конечно, мы наследуемся
 от созданного нами класса Builder. Это нужно для того, чтобы в потомка был доступ
 к шаблонному методу build.
 Теперь есть 2 класса в каждом из которых определены одни и те же методы.
 Но реализвция этих методов абсолютно разное.
 Вся реализация заключаеться лишь в сообщениях выводимых в консоль. И тем не мение,
 если представить эти методы в контексте большого приложения, то их имплементация
 может быть абсолютно разной. Однако, как можно видеть по коду интерфейс взамодействия
 с ними один и то же.
*/

class TeslaBuilder extends Builder {
  addEngine() {
    console.log('Add Electronic Engine');
  }

  installChassis() {
    console.log('Install Tesla chassis');
  }

  addElectronic() {
    console.log('Add special electronic');
  }

  collectAccessories() {
    console.log('Collect Accessories');
  }
}

class BmwBuilder extends Builder {
  addEngine() {
    console.log('Add BMW Engine');
  }

  installChassis() {
    console.log('Install BWM chassis');
  }

  addElectronic() {
    console.log('Add electronic');
  }

  collectAccessories() {
    console.log('Collect Accessories');
  }
}

/* Проверяем реализацию. С помощью двух разных контсрукторов мы создадим 2 разных
 конвеера по зборке авто, операции на которых с технической точки зрения отличаються
 друг от друга. Но общий порядок выполнения этих операций один и тот же. Этот порядок
 можно назвать стандартизированным или шаблонным. Таким образмо, после запуска конвеера,
 мы можем собирать 2 разные модели или выполнять различные алгоритмы шаблонном последовательности.

*/
const teslaBuilder = new TeslaBuilder();
const bmwBuilder = new BmwBuilder();

teslaBuilder.build();
/*
$ node template-method
Add Electronic Engine
Install Tesla chassis
Add special electronic
Collect Accessories
*/

bmwBuilder.build();
/*
Add BMW Engine
Install BWM chassis
Add electronic
Collect Accessories
*/

/* ИТОГ: Шаблонный метод - это патерн, который определяет шаблонное выполнение
  алгоритмов имеющий одинаковый интерфейс взаимодействия, но различную внутреннюю
  имплементацию.
*/
// node template-method