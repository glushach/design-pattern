/* Медиатор (Посредник) - позволяет уменьшить взамосвязь классов между собой,
  внося в межкласовые связи, тк навываемый класс-посредник.

  Например, вы создаете интрефейс небольшого приложения, где пользователь должен
  заполнить данные о себе. Как аналог, можно взять страницу профиля в любой соцсети.
  На этой странице находяться различные дробдауны, чекбоксы, поля форм и тд. Если
  расмотреть функционал ближе, то наример, когда вас просят выбрать страну проживания,
  то вы ее выбираете и у вас появляеться дополнительный дробдаун, с вожмосности выбора
  области или региона. После выбора этой опции у вас появляеться еще один дробдаун
  с выбором города. То есть между элементами страницы устанавливаеться взаимосвязь.
  Таких связей может быть очень много. В результате чего ваша страница условно говоря
  приобретает статический вид. Другими словами из-за большого кол-ва связей,
  вы не можете переиспользовать отдельные элементы вашего интерфейса на других
  страницах. И вот, когда у вас возникает такая проблема, то нужно задуматься о посреднике.
  Как было сказано, медиатор содержит в себе связи между различными элементами,
  ну или классами. Это позволчяет инкапсулировать специфическую логику и переиспользовать
  компоненты. Если брать более простой пример из жизни, когда вы хотите купить новое
  авто, то вы используете салон официального диллера в виде посредника, вместо того,
  чтобы общаться представителями завода напрямую.


  Как было сказано, в качкестве медиатора выступает официальный диллер, который работает
  непосредственно напрямую с вами.
  Класс дилера выглдядит следующим образом.

  Из медиатора мы можем дергать нужные методы клиента.
*/

class OfficialDealer {
  constructor() {
    this.customers = [];
  }

  orderAuto(customer, auto, info) { // делает заказ на завод и автоматически добавляет имя клиента в список клиента
    const name = customer.getName();

    console.log(`Order name: ${name}. Order auto is ${auto}`);
    console.log(`Additional info: ${info}`);
    this.addToCustomersList(name);
  }

  addToCustomersList(name) {
    this.customers.push(name);
  }

  getCustomerList() {
    return this.customers;
  }
}

/* Реализация класса клиента. В нем описана связь с медиатором.
  В конструктор Customer принимает имя класса, и связующее звено, то есть
  медиатор.
  В самом классе метод getName возврящает имя.
  В makeOrder вызываеться метод медиатора orderAuto. Вся прелесть,
  что в Customer нам не нужно нам не нужно описывать само создание
  заказа и завязывать на нем связь с другим классом. Мы фактически получили
  довольно автономный класс, который можно использовать и в других местах,
  а все непосредственные связи, будут происходить в медиаторе или как конкретно
  в нашем случае dealerMediator. В нем мы дергаем дополнительный метод
  addToCustomersList внутри метода orderAuto. И причем, вся элегантность заключаеться
  в том, что класс кастомкр ничего об этом не знает. Ему технически и не нужно об
  этом знать, свою цель он выполнил. Вся магия описываеться нутри посредника.
*/
class Customer {
  constructor(name, dealerMediator) {
    this.name = name;
    this.dealerMediator = dealerMediator;
  }

  getName() {
    return this.name;
  }

  makeOrder(auto, info) {
    this.dealerMediator.orderAuto(this, auto, info);
  }
}

/*
  Создаем инстанс медиатора. Затем создаем 2 клиента и делаем 2 заказа.
  В самом медиаторе оба клиента храняться в списке клиента. Фактически этот
  список можно использовать в другом класса, установив лишь связь с медиатором.
*/
const mediator = new OfficialDealer();

const yauhen = new Customer('Yauhen', mediator);
const valera = new Customer('Valera', mediator);

console.log(yauhen.makeOrder('Tesla', 'With autopilot!'));
/*
  Order name: Yauhen. Order auto is Tesla
  Additional info: With autopilot!
*/
console.log(valera.makeOrder('Audi', 'With parktronic!'))
/*
  Order name: Valera. Order auto is Audi
  Additional info: With parktronic!
*/

console.log(mediator.getCustomerList()); // [ 'Yauhen', 'Valera' ]

/*
  ИТОГ: Медиатор (посредник), нужен для того, чтобы уменьшить связанность
  связанность классов между собой и который устанавливает все необходимые
  связи только внутри себя. Благодаря этому переиспользуемость классов
  увеличиваеться в разы.
*/

// node mediator